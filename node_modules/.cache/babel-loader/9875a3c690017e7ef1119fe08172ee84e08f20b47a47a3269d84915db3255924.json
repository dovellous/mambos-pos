{"ast":null,"code":"// pnp:/home/runner/work/react-thermal-printer/react-thermal-printer/packages/image/src/Image.ts\nfunction floyd_steinberg(image) {\n  const imageData = image.data;\n  const imageDataLength = imageData.length;\n  const w = image.width;\n  const lumR = [],\n    lumG = [],\n    lumB = [];\n  let newPixel, err;\n  for (let i = 0; i < 256; i++) {\n    lumR[i] = i * 0.299;\n    lumG[i] = i * 0.587;\n    lumB[i] = i * 0.11;\n  }\n  for (let i = 0; i <= imageDataLength; i += 4) {\n    imageData[i] = Math.floor(lumR[imageData[i]] + lumG[imageData[i + 1]] + lumB[imageData[i + 2]]);\n  }\n  for (let currentPixel = 0; currentPixel <= imageDataLength; currentPixel += 4) {\n    newPixel = imageData[currentPixel] < 150 ? 0 : 255;\n    err = Math.floor((imageData[currentPixel] - newPixel) / 23);\n    imageData[currentPixel + 0 * 1 - 0] = newPixel;\n    imageData[currentPixel + 4 * 1 - 0] += err * 7;\n    imageData[currentPixel + 4 * w - 4] += err * 3;\n    imageData[currentPixel + 4 * w - 0] += err * 5;\n    imageData[currentPixel + 4 * w + 4] += Number(err);\n    imageData[currentPixel + 1] = imageData[currentPixel + 2] = imageData[currentPixel];\n  }\n  return image;\n}\nvar Image = class {\n  constructor(data, width, height) {\n    this.data = data;\n    this.width = width;\n    this.height = height;\n    const image = {\n      data,\n      width,\n      height\n    };\n    const ditheredImage = floyd_steinberg(image);\n    this.pixels = this.getPixels(ditheredImage.data, width, height);\n  }\n  toRaster() {\n    const data = [];\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < Math.ceil(this.width / 8); j++) {\n        let byte = 0;\n        for (let k = 0; k < 8; k++) {\n          let pixel = this.pixels[i]?.[j * 8 + k];\n          if (pixel === void 0) {\n            pixel = {\n              a: 0,\n              r: 0,\n              g: 0,\n              b: 0\n            };\n          }\n          if (pixel.a > 126) {\n            const grayscale = parseInt(String(0.2126 * pixel.r + 0.7152 * pixel.g + 0.0722 * pixel.b));\n            if (grayscale < 128) {\n              const mask = 1 << 7 - k;\n              byte |= mask;\n            }\n          }\n        }\n        data.push(byte);\n      }\n    }\n    return data;\n  }\n  getPixels(data, width, height) {\n    const pixels = [];\n    for (let i = 0; i < height; i++) {\n      const line = [];\n      for (let j = 0; j < width; j++) {\n        const index = width * i + j << 2;\n        line.push({\n          r: data[index],\n          g: data[index + 1],\n          b: data[index + 2],\n          a: data[index + 3]\n        });\n      }\n      pixels.push(line);\n    }\n    return pixels;\n  }\n};\nexport { Image };","map":{"version":3,"names":["floyd_steinberg","image","imageData","data","imageDataLength","length","w","width","lumR","lumG","lumB","newPixel","err","i","Math","floor","currentPixel","Number","Image","constructor","height","ditheredImage","pixels","getPixels","toRaster","j","ceil","byte","k","pixel","a","r","g","b","grayscale","parseInt","String","mask","push","line","index"],"sources":["pnp:/home/runner/work/react-thermal-printer/react-thermal-printer/packages/image/src/Image.ts"],"sourcesContent":["interface Pixel {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\nfunction floyd_steinberg(image: any) {\n  const imageData = image.data;\n  const imageDataLength = imageData.length;\n  const w = image.width;\n  const lumR = [],\n    lumG = [],\n    lumB = [];\n\n  let newPixel, err;\n\n  for (let i = 0; i < 256; i++) {\n    lumR[i] = i * 0.299;\n    lumG[i] = i * 0.587;\n    lumB[i] = i * 0.11;\n  }\n\n  // Greyscale luminance (sets r pixels to luminance of rgb)\n  for (let i = 0; i <= imageDataLength; i += 4) {\n    imageData[i] = Math.floor(\n      lumR[imageData[i]]! + lumG[imageData[i + 1]]! + lumB[imageData[i + 2]]!\n    );\n  }\n\n  for (let currentPixel = 0; currentPixel <= imageDataLength; currentPixel += 4) {\n    // threshold for determining current pixel's conversion to a black or white pixel\n    newPixel = imageData[currentPixel] < 150 ? 0 : 255;\n    err = Math.floor((imageData[currentPixel] - newPixel) / 23);\n    imageData[currentPixel + 0 * 1 - 0] = newPixel;\n    imageData[currentPixel + 4 * 1 - 0] += err * 7;\n    imageData[currentPixel + 4 * w - 4] += err * 3;\n    imageData[currentPixel + 4 * w - 0] += err * 5;\n    imageData[currentPixel + 4 * w + 4] += Number(err);\n    // Set g and b values equal to r (effectively greyscales the image fully)\n    imageData[currentPixel + 1] = imageData[currentPixel + 2] = imageData[currentPixel];\n  }\n\n  return image;\n}\n\nexport class Image {\n  private readonly pixels: Pixel[][];\n\n  constructor(\n    private readonly data: Uint8Array,\n    private readonly width: number,\n    private readonly height: number\n  ) {\n    const image = { data, width, height };\n    const ditheredImage = floyd_steinberg(image);\n    this.pixels = this.getPixels(ditheredImage.data, width, height);\n  }\n\n  toRaster(): number[] {\n    const data: number[] = [];\n\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < Math.ceil(this.width / 8); j++) {\n        let byte = 0x0;\n        for (let k = 0; k < 8; k++) {\n          let pixel = this.pixels[i]?.[j * 8 + k];\n\n          // Image overflow\n          if (pixel === undefined) {\n            pixel = {\n              a: 0,\n              r: 0,\n              g: 0,\n              b: 0,\n            };\n          }\n\n          if (pixel.a > 126) {\n            // checking transparency\n            const grayscale = parseInt(\n              String(0.2126 * pixel.r + 0.7152 * pixel.g + 0.0722 * pixel.b)\n            );\n\n            if (grayscale < 128) {\n              // checking color\n              const mask = 1 << (7 - k); // setting bitwise mask\n              byte |= mask; // setting the correct bit to 1\n            }\n          }\n        }\n        data.push(byte);\n      }\n    }\n    return data;\n  }\n\n  private getPixels(data: Uint8Array, width: number, height: number): Pixel[][] {\n    const pixels: Pixel[][] = [];\n\n    for (let i = 0; i < height; i++) {\n      const line: Pixel[] = [];\n\n      for (let j = 0; j < width; j++) {\n        const index = (width * i + j) << 2;\n        line.push({\n          r: data[index]!,\n          g: data[index + 1]!,\n          b: data[index + 2]!,\n          a: data[index + 3]!,\n        });\n      }\n\n      pixels.push(line);\n    }\n\n    return pixels;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}